{"ast":null,"code":"import { takeEvery, call, put } from 'redux-saga/effects';\nimport { fetchCollectionsSuccess, fetchCollectionsFailure } from './shop-actions';\nimport { firestore, convertCollectionSnapShotToMap } from '../../components/config/firebase/firebase-util';\nimport { ShopActionTypes } from './shop-types'; // ? Yields give control back to saga middlewre, so saga can cancel \n\nfunction* fetchCollectionsAsync() {\n  try {\n    const collectionRef = firestore.collection('collections');\n    const snapshot = yield collectionRef.get(); // ? call invokes function , within saga\n\n    const collectionsMap = yield call(convertCollectionSnapShotToMap, snapshot); // ? Put is saga efffect to dispatch action\n\n    yield put(fetchCollectionsSuccess(collectionsMap));\n  } catch (error) {\n    yield put(fetchCollectionsFailure(error));\n  } // ? Thunk method\n  // collectionRef.get()\n  //     .then(snapshot => {\n  //         const collectionsMap = convertCollectionSnapShotToMap(snapshot)\n  //         // console.log(`&&&&&&&&&&&&&&&&&&&&&&&&& MAP: `,collectionsMap)\n  //         dispatch(fetchCollectionsSuccess(collectionsMap))\n  //     })\n  //     .catch(error => dispatch(fetchCollectionsFailure(error)))\n\n} // ? Saga determines whether or not to cancel sagas\n\n\nexport function* fetchCollectionStart() {\n  // ? Takeevery creates a nonblocking code so app still other scripts or sagas are not blocked\n  yield takeEvery(ShopActionTypes.FETCH_COLLECTIONS_START, // action this saga listens for\n  fetchCollectionsAsync // what is excecuted and controled by saga\n  );\n}","map":{"version":3,"sources":["/Users/alexanderhoinville/Desktop/GitHub/ecommerce/src/redux/shop/shop-sagas.js"],"names":["takeEvery","call","put","fetchCollectionsSuccess","fetchCollectionsFailure","firestore","convertCollectionSnapShotToMap","ShopActionTypes","fetchCollectionsAsync","collectionRef","collection","snapshot","get","collectionsMap","error","fetchCollectionStart","FETCH_COLLECTIONS_START"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,IAApB,EAA0BC,GAA1B,QAAqC,oBAArC;AAEA,SACIC,uBADJ,EAEIC,uBAFJ,QAGO,gBAHP;AAKA,SAASC,SAAT,EAAoBC,8BAApB,QAA0D,gDAA1D;AACA,SAASC,eAAT,QAAgC,cAAhC,C,CAGA;;AACA,UAAUC,qBAAV,GAAkC;AAI9B,MAAI;AAEA,UAAMC,aAAa,GAAGJ,SAAS,CAACK,UAAV,CAAqB,aAArB,CAAtB;AACA,UAAMC,QAAQ,GAAG,MAAMF,aAAa,CAACG,GAAd,EAAvB,CAHA,CAKA;;AACA,UAAMC,cAAc,GAAG,MAAMZ,IAAI,CAACK,8BAAD,EAAiCK,QAAjC,CAAjC,CANA,CAQA;;AACA,UAAMT,GAAG,CAACC,uBAAuB,CAACU,cAAD,CAAxB,CAAT;AAEH,GAXD,CAWE,OAAOC,KAAP,EAAc;AACZ,UAAMZ,GAAG,CAACE,uBAAuB,CAACU,KAAD,CAAxB,CAAT;AACH,GAjB6B,CAoB9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGH,C,CAED;;;AACA,OAAO,UAAUC,oBAAV,GAAiC;AAEpC;AACA,QAAMf,SAAS,CACXO,eAAe,CAACS,uBADL,EAC8B;AACzCR,EAAAA,qBAFW,CAEW;AAFX,GAAf;AAKH","sourcesContent":["import { takeEvery, call, put } from 'redux-saga/effects'\n\nimport {\n    fetchCollectionsSuccess,\n    fetchCollectionsFailure\n} from './shop-actions'\n\nimport { firestore, convertCollectionSnapShotToMap } from '../../components/config/firebase/firebase-util'\nimport { ShopActionTypes } from './shop-types'\n\n\n// ? Yields give control back to saga middlewre, so saga can cancel \nfunction* fetchCollectionsAsync() {\n\n\n\n    try {\n\n        const collectionRef = firestore.collection('collections')\n        const snapshot = yield collectionRef.get()\n\n        // ? call invokes function , within saga\n        const collectionsMap = yield call(convertCollectionSnapShotToMap, snapshot)\n\n        // ? Put is saga efffect to dispatch action\n        yield put(fetchCollectionsSuccess(collectionsMap))\n\n    } catch (error) {\n        yield put(fetchCollectionsFailure(error))\n    }\n\n\n    // ? Thunk method\n    // collectionRef.get()\n    //     .then(snapshot => {\n    //         const collectionsMap = convertCollectionSnapShotToMap(snapshot)\n    //         // console.log(`&&&&&&&&&&&&&&&&&&&&&&&&& MAP: `,collectionsMap)\n    //         dispatch(fetchCollectionsSuccess(collectionsMap))\n    //     })\n    //     .catch(error => dispatch(fetchCollectionsFailure(error)))\n\n\n}\n\n// ? Saga determines whether or not to cancel sagas\nexport function* fetchCollectionStart() {\n\n    // ? Takeevery creates a nonblocking code so app still other scripts or sagas are not blocked\n    yield takeEvery(\n        ShopActionTypes.FETCH_COLLECTIONS_START, // action this saga listens for\n        fetchCollectionsAsync // what is excecuted and controled by saga\n    )\n\n}"]},"metadata":{},"sourceType":"module"}