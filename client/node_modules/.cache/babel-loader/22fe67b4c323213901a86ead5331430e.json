{"ast":null,"code":"const express = require('express');\n\nconst cors = require('cors');\n\nconst bodyParser = require('body-parser');\n\nconst path = require('path');\n\nif (process.env.NODE_ENV !== 'production') require('dotenv').config();\n\nconst stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);\n\nconst app = express();\nconst port = process.env.PORT || 5000;\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({\n  extended: true\n}));\napp.use(cors());\n\nif (process.env.NODE_ENV === 'production') {\n  app.use(express.static(path.join(__dirname, 'client/build')));\n  app.get('*', function (req, res) {\n    res.sendFile(path.join(__dirname, 'client/build', 'index.html'));\n  });\n}\n\napp.listen(port, error => {\n  if (error) throw error;\n  console.log('Server running on port ' + port);\n});\napp.post('/payment', (req, res) => {\n  const body = {\n    source: req.body.token.id,\n    amount: req.body.amount,\n    currency: 'usd'\n  };\n  stripe.charges.create(body, (stripeErr, stripeRes) => {\n    if (stripeErr) {\n      res.status(500).send({\n        error: stripeErr\n      });\n    } else {\n      res.status(200).send({\n        success: stripeRes\n      });\n    }\n  });\n}); // // Firebase App (the core Firebase SDK) is always required and must be listed first\n// import firebase from 'firebase/app'\n// // Add the Firebase products that you want to use\n// import \"firebase/auth\"; // authorization\n// import \"firebase/firestore\"; // database\n// // Web app's Firebase configuration\n// const firebaseConfig = {\n//     apiKey: \"AIzaSyBl9ZmTbt226YVEKmxUuyJDfh18NibTvbk\",\n//     authDomain: \"diamond-clothing.firebaseapp.com\",\n//     databaseURL: \"https://diamond-clothing.firebaseio.com\",\n//     projectId: \"diamond-clothing\",\n//     storageBucket: \"diamond-clothing.appspot.com\",\n//     messagingSenderId: \"390969946473\",\n//     appId: \"1:390969946473:web:30cd40e5222176a5394df8\",\n//     measurementId: \"G-P2DZVE7MP2\"\n//   };\n// // ? Initialize our instance of Firebase\n// firebase.initializeApp(firebaseConfig);\n// // ? Export Libraries for use\n// export const auth = firebase.auth()\n// export const firestore = firebase.firestore();\n// // ? Save a user to DB as document if it does not exist already\n// export const createUserProfileDocument = async (userAuth, additionalData) => {\n//     if (!userAuth) {\n//         return\n//     };\n//     // ? Get query reference object from FIrebase at locatoion to get snapshot\n//     // ? Reference will ALWAYS return something even if nothing exsists, use snap to make sure something exsists \n//     const userRef = firestore.doc(`users/${userAuth.uid}`);\n//     // ! Sanpshot required to check if anything exsists at location\n//     const snapShot = await userRef.get();\n//     // ? Use snapshot to check if anything exsists in this location, create a document if not\n//     if (!snapShot.exists) {\n//         // ? Provide user data for the doc from the user provided in argument\n//         const { email } = userAuth;\n//         const createdAt = new Date();\n//         try {\n//             // ? Use document refrence for CRUD operations (create in this case)\n//             await userRef.set({\n//                 email,\n//                 createdAt,\n//                 ...additionalData // name\n//             });\n//         } catch (error) {\n//             console.log('error creating user', error.message);\n//         }\n//     }\n//     // ? Return userRef in case more changes are wanted to be made\n//     return userRef;\n// };\n// // ? The Google provider class for google auth\n// export const googleProvider = new firebase.auth.GoogleAuthProvider();\n// googleProvider.setCustomParameters({ prompt: 'select_account' })\n// export const googleSignIn = () => auth.signInWithPopup(googleProvider)\n// export const signOut = () => {\n//     firebase.auth().signOut()\n//         .then(function () {\n//             // Sign-out successful.\n//         }).catch(function (error) {\n//             // An error happened.\n//         });\n// }\n// // ? Convert a collection to hash map\n// export const convertCollectionSnapShotToMap = (collectionSnapshotObject) => {\n//     // ? Maps over array of docs in collection snapshot and returns object with desired data for use\n//     const transformedCollection = collectionSnapshotObject.docs.map((document) => {\n//         // ? Extract data from document\n//         const { title, items } = document.data();\n//         // ? Return Data from document after adding route and id of object \n//         return {\n//             // ? encode for routes\n//             routeName: encodeURI(title.toLowerCase()),\n//             id: document.id,\n//             title,\n//             items\n//         }\n//     })\n//     // ? Returns hash map from array of documents ex. {hats: {hatsCollectionobject} }\n//     return transformedCollection.reduce((accumulator, collection) => {\n//         accumulator[collection.title.toLowerCase()] = collection;\n//         // console.log(`ACCUMULATOR ******** `,accumulator)\n//         return accumulator;\n//     }, {}\n//     )\n// }\n// export const addCollectionAndDocumentss = async (collectionKey, objectsToAdd) => {\n//     const collectionRef = firestore.collection(collectionKey)\n//     // Create Batch instance\n//     const batch = firestore.batch();\n//     objectsToAdd.forEach(obj => {\n//         // ? Create new docReference Objects for each key in object (Creates UniqueId if doc() empty)\n//         const newDocRef = collectionRef.doc()\n//         // ? batch all set operations that will be done on eaach key\n//         batch.set(newDocRef, obj)\n//     })\n//     await batch.commit()\n// }\n// // ? Observer that returns consumable promise\n// export const getCurrentUser = () => {\n//     return new Promise((resolve, reject) => {\n//         // ? onAuth provides argument for userAuth\n//         const unsubscribe = auth.onAuthStateChanged(userAuth => {\n//             unsubscribe();\n//             resolve(userAuth)\n//         },reject)\n//     }\n//     )\n// }\n// export default firebase","map":{"version":3,"sources":["/Users/alexanderhoinville/Desktop/GitHub/ecommerce/client/src/components/config/firebase/firebase-util.js"],"names":["express","require","cors","bodyParser","path","process","env","NODE_ENV","config","stripe","STRIPE_SECRET_KEY","app","port","PORT","use","json","urlencoded","extended","static","join","__dirname","get","req","res","sendFile","listen","error","console","log","post","body","source","token","id","amount","currency","charges","create","stripeErr","stripeRes","status","send","success"],"mappings":"AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AACA,MAAME,UAAU,GAAGF,OAAO,CAAC,aAAD,CAA1B;;AACA,MAAMG,IAAI,GAAGH,OAAO,CAAC,MAAD,CAApB;;AAEA,IAAII,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2CN,OAAO,CAAC,QAAD,CAAP,CAAkBO,MAAlB;;AAE3C,MAAMC,MAAM,GAAGR,OAAO,CAAC,QAAD,CAAP,CAAkBI,OAAO,CAACC,GAAR,CAAYI,iBAA9B,CAAf;;AAEA,MAAMC,GAAG,GAAGX,OAAO,EAAnB;AACA,MAAMY,IAAI,GAAGP,OAAO,CAACC,GAAR,CAAYO,IAAZ,IAAoB,IAAjC;AAEAF,GAAG,CAACG,GAAJ,CAAQX,UAAU,CAACY,IAAX,EAAR;AACAJ,GAAG,CAACG,GAAJ,CAAQX,UAAU,CAACa,UAAX,CAAsB;AAAEC,EAAAA,QAAQ,EAAE;AAAZ,CAAtB,CAAR;AAEAN,GAAG,CAACG,GAAJ,CAAQZ,IAAI,EAAZ;;AAEA,IAAIG,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACvCI,EAAAA,GAAG,CAACG,GAAJ,CAAQd,OAAO,CAACkB,MAAR,CAAed,IAAI,CAACe,IAAL,CAAUC,SAAV,EAAqB,cAArB,CAAf,CAAR;AAEAT,EAAAA,GAAG,CAACU,GAAJ,CAAQ,GAAR,EAAa,UAAUC,GAAV,EAAeC,GAAf,EAAoB;AAC7BA,IAAAA,GAAG,CAACC,QAAJ,CAAapB,IAAI,CAACe,IAAL,CAAUC,SAAV,EAAqB,cAArB,EAAqC,YAArC,CAAb;AACH,GAFD;AAGH;;AAEDT,GAAG,CAACc,MAAJ,CAAWb,IAAX,EAAiBc,KAAK,IAAI;AACtB,MAAIA,KAAJ,EAAW,MAAMA,KAAN;AACXC,EAAAA,OAAO,CAACC,GAAR,CAAY,4BAA4BhB,IAAxC;AACH,CAHD;AAKAD,GAAG,CAACkB,IAAJ,CAAS,UAAT,EAAqB,CAACP,GAAD,EAAMC,GAAN,KAAc;AAC/B,QAAMO,IAAI,GAAG;AACTC,IAAAA,MAAM,EAAET,GAAG,CAACQ,IAAJ,CAASE,KAAT,CAAeC,EADd;AAETC,IAAAA,MAAM,EAAEZ,GAAG,CAACQ,IAAJ,CAASI,MAFR;AAGTC,IAAAA,QAAQ,EAAE;AAHD,GAAb;AAMA1B,EAAAA,MAAM,CAAC2B,OAAP,CAAeC,MAAf,CAAsBP,IAAtB,EAA4B,CAACQ,SAAD,EAAYC,SAAZ,KAA0B;AAClD,QAAID,SAAJ,EAAe;AACXf,MAAAA,GAAG,CAACiB,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEf,QAAAA,KAAK,EAAEY;AAAT,OAArB;AACH,KAFD,MAEO;AACHf,MAAAA,GAAG,CAACiB,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,QAAAA,OAAO,EAAEH;AAAX,OAArB;AACH;AACJ,GAND;AAOH,CAdD,E,CAgBA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA","sourcesContent":["const express = require('express');\nconst cors = require('cors');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nif (process.env.NODE_ENV !== 'production') require('dotenv').config();\n\nconst stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);\n\nconst app = express();\nconst port = process.env.PORT || 5000;\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.use(cors());\n\nif (process.env.NODE_ENV === 'production') {\n    app.use(express.static(path.join(__dirname, 'client/build')));\n\n    app.get('*', function (req, res) {\n        res.sendFile(path.join(__dirname, 'client/build', 'index.html'));\n    });\n}\n\napp.listen(port, error => {\n    if (error) throw error;\n    console.log('Server running on port ' + port);\n});\n\napp.post('/payment', (req, res) => {\n    const body = {\n        source: req.body.token.id,\n        amount: req.body.amount,\n        currency: 'usd'\n    };\n\n    stripe.charges.create(body, (stripeErr, stripeRes) => {\n        if (stripeErr) {\n            res.status(500).send({ error: stripeErr });\n        } else {\n            res.status(200).send({ success: stripeRes });\n        }\n    });\n});\n\n// // Firebase App (the core Firebase SDK) is always required and must be listed first\n// import firebase from 'firebase/app'\n\n// // Add the Firebase products that you want to use\n// import \"firebase/auth\"; // authorization\n// import \"firebase/firestore\"; // database\n\n// // Web app's Firebase configuration\n// const firebaseConfig = {\n//     apiKey: \"AIzaSyBl9ZmTbt226YVEKmxUuyJDfh18NibTvbk\",\n//     authDomain: \"diamond-clothing.firebaseapp.com\",\n//     databaseURL: \"https://diamond-clothing.firebaseio.com\",\n//     projectId: \"diamond-clothing\",\n//     storageBucket: \"diamond-clothing.appspot.com\",\n//     messagingSenderId: \"390969946473\",\n//     appId: \"1:390969946473:web:30cd40e5222176a5394df8\",\n//     measurementId: \"G-P2DZVE7MP2\"\n//   };\n\n// // ? Initialize our instance of Firebase\n// firebase.initializeApp(firebaseConfig);\n\n// // ? Export Libraries for use\n// export const auth = firebase.auth()\n// export const firestore = firebase.firestore();\n\n// // ? Save a user to DB as document if it does not exist already\n// export const createUserProfileDocument = async (userAuth, additionalData) => {\n\n//     if (!userAuth) {\n//         return\n//     };\n\n//     // ? Get query reference object from FIrebase at locatoion to get snapshot\n//     // ? Reference will ALWAYS return something even if nothing exsists, use snap to make sure something exsists \n//     const userRef = firestore.doc(`users/${userAuth.uid}`);\n\n//     // ! Sanpshot required to check if anything exsists at location\n//     const snapShot = await userRef.get();\n\n\n//     // ? Use snapshot to check if anything exsists in this location, create a document if not\n//     if (!snapShot.exists) {\n\n//         // ? Provide user data for the doc from the user provided in argument\n//         const { email } = userAuth;\n//         const createdAt = new Date();\n\n//         try {\n//             // ? Use document refrence for CRUD operations (create in this case)\n//             await userRef.set({\n//                 email,\n//                 createdAt,\n//                 ...additionalData // name\n//             });\n//         } catch (error) {\n//             console.log('error creating user', error.message);\n//         }\n//     }\n\n//     // ? Return userRef in case more changes are wanted to be made\n//     return userRef;\n\n// };\n\n\n\n// // ? The Google provider class for google auth\n// export const googleProvider = new firebase.auth.GoogleAuthProvider();\n// googleProvider.setCustomParameters({ prompt: 'select_account' })\n\n\n// export const googleSignIn = () => auth.signInWithPopup(googleProvider)\n\n// export const signOut = () => {\n//     firebase.auth().signOut()\n//         .then(function () {\n//             // Sign-out successful.\n//         }).catch(function (error) {\n//             // An error happened.\n//         });\n// }\n\n// // ? Convert a collection to hash map\n// export const convertCollectionSnapShotToMap = (collectionSnapshotObject) => {\n\n//     // ? Maps over array of docs in collection snapshot and returns object with desired data for use\n//     const transformedCollection = collectionSnapshotObject.docs.map((document) => {\n\n//         // ? Extract data from document\n//         const { title, items } = document.data();\n\n//         // ? Return Data from document after adding route and id of object \n//         return {\n//             // ? encode for routes\n//             routeName: encodeURI(title.toLowerCase()),\n//             id: document.id,\n//             title,\n//             items\n//         }\n\n//     })\n\n//     // ? Returns hash map from array of documents ex. {hats: {hatsCollectionobject} }\n//     return transformedCollection.reduce((accumulator, collection) => {\n\n//         accumulator[collection.title.toLowerCase()] = collection;\n//         // console.log(`ACCUMULATOR ******** `,accumulator)\n//         return accumulator;\n\n//     }, {}\n//     )\n\n// }\n\n// export const addCollectionAndDocumentss = async (collectionKey, objectsToAdd) => {\n//     const collectionRef = firestore.collection(collectionKey)\n\n//     // Create Batch instance\n//     const batch = firestore.batch();\n\n//     objectsToAdd.forEach(obj => {\n\n//         // ? Create new docReference Objects for each key in object (Creates UniqueId if doc() empty)\n//         const newDocRef = collectionRef.doc()\n\n//         // ? batch all set operations that will be done on eaach key\n//         batch.set(newDocRef, obj)\n\n//     })\n\n//     await batch.commit()\n\n// }\n\n// // ? Observer that returns consumable promise\n// export const getCurrentUser = () => {\n//     return new Promise((resolve, reject) => {\n\n//         // ? onAuth provides argument for userAuth\n//         const unsubscribe = auth.onAuthStateChanged(userAuth => {\n//             unsubscribe();\n//             resolve(userAuth)\n//         },reject)\n//     }\n//     )\n// }\n\n// export default firebase"]},"metadata":{},"sourceType":"module"}