{"ast":null,"code":"import { takeLatest, call, put } from 'redux-saga/effects';\nimport { fetchCollectionsSuccess, fetchCollectionsFailure } from './shop-actions';\nimport { firestore, convertCollectionSnapShotToMap } from '../../components/config/firebase/firebase-util';\nimport { ShopActionTypes } from './shop-types'; // ? Yields give control back to saga middlewre, so saga can cancel a saga if it wants/needs to\n// ? takeLatest : will take tasks , but cancel previous ones if they are not finished and will use latest tasks\n// ? takeEvery : Runs every task concurrently\n// Generator functions necesarry for sagas \n\nfunction* fetchCollectionsAsync() {\n  try {\n    const collectionRef = firestore.collection('collections');\n    const snapshot = yield collectionRef.get(); // ? call invokes function , within saga\n\n    const collectionsMap = yield call(convertCollectionSnapShotToMap, snapshot); // ? Put is saga efffect to dispatch action\n\n    yield put(fetchCollectionsSuccess(collectionsMap));\n  } catch (error) {\n    yield put(fetchCollectionsFailure(error));\n  }\n} // ? Saga determines whether or not to cancel sagas\n\n\nexport function* fetchCollectionStart() {\n  // ? Latest becuase only need this task completed once\n  yield takeLatest(ShopActionTypes.FETCH_COLLECTIONS_START, // action this saga listens for\n  fetchCollectionsAsync // what is excecuted and controled by saga\n  );\n}","map":{"version":3,"sources":["/Users/alexanderhoinville/Desktop/GitHub/ecommerce/src/redux/shop/shop-sagas.js"],"names":["takeLatest","call","put","fetchCollectionsSuccess","fetchCollectionsFailure","firestore","convertCollectionSnapShotToMap","ShopActionTypes","fetchCollectionsAsync","collectionRef","collection","snapshot","get","collectionsMap","error","fetchCollectionStart","FETCH_COLLECTIONS_START"],"mappings":"AAAA,SAASA,UAAT,EAAqBC,IAArB,EAA2BC,GAA3B,QAAsC,oBAAtC;AAEA,SACIC,uBADJ,EAEIC,uBAFJ,QAGO,gBAHP;AAKA,SAASC,SAAT,EAAoBC,8BAApB,QAA0D,gDAA1D;AACA,SAASC,eAAT,QAAgC,cAAhC,C,CAEA;AACA;AACA;AAEA;;AACA,UAAUC,qBAAV,GAAkC;AAE9B,MAAI;AAEA,UAAMC,aAAa,GAAGJ,SAAS,CAACK,UAAV,CAAqB,aAArB,CAAtB;AACA,UAAMC,QAAQ,GAAG,MAAMF,aAAa,CAACG,GAAd,EAAvB,CAHA,CAKA;;AACA,UAAMC,cAAc,GAAG,MAAMZ,IAAI,CAACK,8BAAD,EAAiCK,QAAjC,CAAjC,CANA,CAQA;;AACA,UAAMT,GAAG,CAACC,uBAAuB,CAACU,cAAD,CAAxB,CAAT;AAEH,GAXD,CAWE,OAAOC,KAAP,EAAc;AACZ,UAAMZ,GAAG,CAACE,uBAAuB,CAACU,KAAD,CAAxB,CAAT;AACH;AAEJ,C,CAED;;;AACA,OAAO,UAAUC,oBAAV,GAAiC;AAEpC;AACA,QAAMf,UAAU,CACZO,eAAe,CAACS,uBADJ,EAC6B;AACzCR,EAAAA,qBAFY,CAEU;AAFV,GAAhB;AAKH","sourcesContent":["import { takeLatest, call, put } from 'redux-saga/effects'\n\nimport {\n    fetchCollectionsSuccess,\n    fetchCollectionsFailure\n} from './shop-actions'\n\nimport { firestore, convertCollectionSnapShotToMap } from '../../components/config/firebase/firebase-util'\nimport { ShopActionTypes } from './shop-types'\n\n// ? Yields give control back to saga middlewre, so saga can cancel a saga if it wants/needs to\n// ? takeLatest : will take tasks , but cancel previous ones if they are not finished and will use latest tasks\n// ? takeEvery : Runs every task concurrently\n\n// Generator functions necesarry for sagas \nfunction* fetchCollectionsAsync() {\n\n    try {\n\n        const collectionRef = firestore.collection('collections')\n        const snapshot = yield collectionRef.get()\n\n        // ? call invokes function , within saga\n        const collectionsMap = yield call(convertCollectionSnapShotToMap, snapshot)\n\n        // ? Put is saga efffect to dispatch action\n        yield put(fetchCollectionsSuccess(collectionsMap))\n\n    } catch (error) {\n        yield put(fetchCollectionsFailure(error))\n    }\n\n}\n\n// ? Saga determines whether or not to cancel sagas\nexport function* fetchCollectionStart() {\n\n    // ? Latest becuase only need this task completed once\n    yield takeLatest(\n        ShopActionTypes.FETCH_COLLECTIONS_START, // action this saga listens for\n        fetchCollectionsAsync // what is excecuted and controled by saga\n    )\n\n}"]},"metadata":{},"sourceType":"module"}